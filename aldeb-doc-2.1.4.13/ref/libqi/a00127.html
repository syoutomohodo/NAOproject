<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>qi::path Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div class="related">
  <ul>
    <!-- <li style="margin-right: 10px" class="right"> -->
    <!--   <a accesskey="I" title="General Index" href="genindex.html">index</a> -->
    <!-- </li> -->
    <!-- <li class="right"> -->
    <!--   <a accesskey="N" title="What’s new?" href="news/whatsnew/index.html">next</a> | -->
    <!-- </li> -->
    <li><a href="../../index.html">Aldebaran documentation</a> |</li>
    <li><a href="../../ref/cpp-api.html">C++ Libraries</a> |</li>
    <li><a href="index.html">index</a></li>
  </ul>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="width: 100%">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libqi-api
   &#160;<span id="projectnumber">2.1.4.13</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00121.html">qi</a></li><li class="navelem"><a class="el" href="a00127.html">path</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">qi::path Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Set of tools to handle SDK layouts.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:a00128"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a58ef35d77f49e66ea2f6a35bf7503173"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html#a58ef35d77f49e66ea2f6a35bf7503173">sdkPrefix</a> ()</td></tr>
<tr class="memdesc:a58ef35d77f49e66ea2f6a35bf7503173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the default SDK prefix path.  <a href="#a58ef35d77f49e66ea2f6a35bf7503173">More...</a><br/></td></tr>
<tr class="separator:a58ef35d77f49e66ea2f6a35bf7503173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ef27889b690c2afa077fb6151bcae4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html#a26ef27889b690c2afa077fb6151bcae4">findBin</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a26ef27889b690c2afa077fb6151bcae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look for a binary.  <a href="#a26ef27889b690c2afa077fb6151bcae4">More...</a><br/></td></tr>
<tr class="separator:a26ef27889b690c2afa077fb6151bcae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3bafbaf3f9c49b290ced4515fdc4050"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html#ae3bafbaf3f9c49b290ced4515fdc4050">findLib</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ae3bafbaf3f9c49b290ced4515fdc4050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look for a library.  <a href="#ae3bafbaf3f9c49b290ced4515fdc4050">More...</a><br/></td></tr>
<tr class="separator:ae3bafbaf3f9c49b290ced4515fdc4050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa002839d3d1b10221b2556b52c0f4be9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html#aa002839d3d1b10221b2556b52c0f4be9">findConf</a> (const std::string &amp;applicationName, const std::string &amp;filename)</td></tr>
<tr class="memdesc:aa002839d3d1b10221b2556b52c0f4be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look for a configuration file.  <a href="#aa002839d3d1b10221b2556b52c0f4be9">More...</a><br/></td></tr>
<tr class="separator:aa002839d3d1b10221b2556b52c0f4be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15f907e9a27e43d2341adcfb2b1880d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html#ab15f907e9a27e43d2341adcfb2b1880d">findData</a> (const std::string &amp;applicationName, const std::string &amp;filename)</td></tr>
<tr class="separator:ab15f907e9a27e43d2341adcfb2b1880d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf76bbd1a7cae43f587b73cc93476ee9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html#abf76bbd1a7cae43f587b73cc93476ee9">listData</a> (const std::string &amp;applicationName, const std::string &amp;pattern=&quot;*&quot;)</td></tr>
<tr class="separator:abf76bbd1a7cae43f587b73cc93476ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4833e84834a6905c3975f37cc47e4dad"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html#a4833e84834a6905c3975f37cc47e4dad">confPaths</a> (const std::string &amp;applicationName=&quot;&quot;)</td></tr>
<tr class="memdesc:a4833e84834a6905c3975f37cc47e4dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of directories used when searching for configuration files for the given application name.  <a href="#a4833e84834a6905c3975f37cc47e4dad">More...</a><br/></td></tr>
<tr class="separator:a4833e84834a6905c3975f37cc47e4dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9021f1fb839ae78ff4b3a739112c5c06"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html#a9021f1fb839ae78ff4b3a739112c5c06">dataPaths</a> (const std::string &amp;applicationName=&quot;&quot;)</td></tr>
<tr class="memdesc:a9021f1fb839ae78ff4b3a739112c5c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of directories used when searching for data files for the given application name.  <a href="#a9021f1fb839ae78ff4b3a739112c5c06">More...</a><br/></td></tr>
<tr class="separator:a9021f1fb839ae78ff4b3a739112c5c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856870aca1dad5fb007b7e18c976c0ec"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html#a856870aca1dad5fb007b7e18c976c0ec">binPaths</a> ()</td></tr>
<tr class="memdesc:a856870aca1dad5fb007b7e18c976c0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of directories used when searching for binaries.  <a href="#a856870aca1dad5fb007b7e18c976c0ec">More...</a><br/></td></tr>
<tr class="separator:a856870aca1dad5fb007b7e18c976c0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf19f007a5751a28f92aeca95a66dbef"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html#adf19f007a5751a28f92aeca95a66dbef">libPaths</a> ()</td></tr>
<tr class="memdesc:adf19f007a5751a28f92aeca95a66dbef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of directories used when searching for libraries.  <a href="#adf19f007a5751a28f92aeca95a66dbef">More...</a><br/></td></tr>
<tr class="separator:adf19f007a5751a28f92aeca95a66dbef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fbae233ad984a160a1cbd4bc0f0ffd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html#a28fbae233ad984a160a1cbd4bc0f0ffd">setWritablePath</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a28fbae233ad984a160a1cbd4bc0f0ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the writable files path for users.  <a href="#a28fbae233ad984a160a1cbd4bc0f0ffd">More...</a><br/></td></tr>
<tr class="separator:a28fbae233ad984a160a1cbd4bc0f0ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dbd19303a2be34b9ee8391c336f2a52"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html#a4dbd19303a2be34b9ee8391c336f2a52">userWritableDataPath</a> (const std::string &amp;applicationName, const std::string &amp;filename)</td></tr>
<tr class="memdesc:a4dbd19303a2be34b9ee8391c336f2a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the writable data files path for users.  <a href="#a4dbd19303a2be34b9ee8391c336f2a52">More...</a><br/></td></tr>
<tr class="separator:a4dbd19303a2be34b9ee8391c336f2a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b005e1a08fe22acb98b0c237c0db803"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html#a2b005e1a08fe22acb98b0c237c0db803">userWritableConfPath</a> (const std::string &amp;applicationName, const std::string &amp;filename=&quot;&quot;)</td></tr>
<tr class="memdesc:a2b005e1a08fe22acb98b0c237c0db803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the writable configuration files path for users.  <a href="#a2b005e1a08fe22acb98b0c237c0db803">More...</a><br/></td></tr>
<tr class="separator:a2b005e1a08fe22acb98b0c237c0db803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4de5c45ebedcb2a533a850adf9692d4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html#ac4de5c45ebedcb2a533a850adf9692d4">convertToDosPath</a> (const std::string &amp;pathString)</td></tr>
<tr class="separator:ac4de5c45ebedcb2a533a850adf9692d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Set of tools to handle SDK layouts. </p>
<pre class="fragment">* .. note::
*     Every string MUST be encoded in UTF-8. Every returned string are encoded in UTF-8.
* </pre> </div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a856870aca1dad5fb007b7e18c976c0ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qi::path::binPaths </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the list of directories used when searching for binaries. </p>
<dl class="section return"><dt>Returns</dt><dd>A list of directories.</dd></dl>
<pre class="fragment">* This is used by the :cpp:func:`qi::path::findBin(const std::string&amp;)`.
*
* .. warning:: You should not assume those directories exist, nor that they are
*    writeable.
* </pre> 
</div>
</div>
<a class="anchor" id="a4833e84834a6905c3975f37cc47e4dad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qi::path::confPaths </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>applicationName</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the list of directories used when searching for configuration files for the given application name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">applicationName</td><td>Name of the application. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of configuration directories.</dd></dl>
<pre class="fragment">* This is used by the :cpp:func:`qi::path::findConf(const std::string&amp;, const std::string&amp;)`.
*
* .. warning:: You should not assume those directories exist, nor
*    that they are writeable.
* </pre> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00001.html#a5">qipath_example.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ac4de5c45ebedcb2a533a850adf9692d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string qi::path::convertToDosPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pathString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert given path into DOS 8.3 path if it exists, else returns empty string (Windows only). To use some API that doesn't support unicode on Windows, it is possible to convert a unicode path to an existing file into a DOS path without any accentuated characters. (for ex. "C:\test àé\" becomes "C:\TEST~1\" if it already exists)</p>
<p>On other platforms, simply return pathString. </p>

</div>
</div>
<a class="anchor" id="a9021f1fb839ae78ff4b3a739112c5c06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qi::path::dataPaths </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>applicationName</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the list of directories used when searching for data files for the given application name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">applicationName</td><td>Name of the application. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of directories.</dd></dl>
<pre class="fragment">* This is used by the :cpp:func:`qi::path::findData(const std::string&amp;, const std::string&amp;)`
* and the :cpp:func:`qi::path::listData(const std::string&amp;, const std::string&amp;)`.
*
* The list of paths is constructed like this:
*
* - first, a standard path in the home directory (like
*   ~/.local/share/&lt;applicationName&gt;/&lt;filename&gt;)
* - then &lt;sdk_prefix&gt;/share/&lt;applicationName&gt;/&lt;filename&gt; for each known SDK
*   prefix.
*
* .. warning:: You should not assume those directories exist,
*    nor that they are writeable.
* </pre> 
</div>
</div>
<a class="anchor" id="a26ef27889b690c2afa077fb6151bcae4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qi::path::findBin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look for a binary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The full name of the binary, or just the name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complete, native path to the file found, an empty string otherwise.</dd></dl>
<pre class="fragment">* This will search in all SDK prefixes for a file named 'name'.
* It will then add '.exe' suffix if needed.
* (without '.exe') (in UTF-8).
* </pre> 
</div>
</div>
<a class="anchor" id="aa002839d3d1b10221b2556b52c0f4be9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qi::path::findConf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>applicationName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look for a configuration file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">applicationName</td><td>Name of the application. </td></tr>
    <tr><td class="paramname">filename</td><td>Name of the file to look for. You can specify subdirectories using "/" as directory separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complete, native path of the file if it was found, an empty string otherwise.</dd></dl>
<pre class="fragment">* The file is searched in a list of possible directories,
* the first match is returned.
*
* The list of paths is constructed like this:
*
* - first, a standard path in the home directory (like
*   ~/.config/&lt;applicationName&gt;/&lt;filename&gt;)
* - then: &lt;sdk_prefix&gt;/etc/&lt;applicationName&gt;/&lt;filename&gt; for each known SDK
*   prefix.
* - then a standard path in the system. (like
*   /etc/&lt;applicationName&gt;/&lt;filename&gt;)
* </pre> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00001.html#a4">qipath_example.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab15f907e9a27e43d2341adcfb2b1880d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qi::path::findData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>applicationName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Look for a file in all dataPaths(applicationName) directories, return the first match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">applicationName</td><td>Name of the application. </td></tr>
    <tr><td class="paramname">filename</td><td>Name of the file to look for. You can specify subdirectories using "/" as directory separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complete, native path of the file if it was found, an empty string otherwise.</dd></dl>
<pre class="fragment">* The file is searched in a list of possible directories, provided by the
* :cpp:func:`qi::path::dataPaths(const std::string&amp;)`.
* The first match is returned.
*
* For instance if you have the following files on a unix system
*
*   ~/.local/share/foo/models/nao.xml
*   /usr/share/foo/models/nao.xml
*
* then listData("foo", "models/nao.xml") will return
*
*   ~/.local/share/foo/models/nao.xml
* </pre> 
</div>
</div>
<a class="anchor" id="ae3bafbaf3f9c49b290ced4515fdc4050"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string qi::path::findLib </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look for a library. </p>

</div>
</div>
<a class="anchor" id="adf19f007a5751a28f92aeca95a66dbef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qi::path::libPaths </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the list of directories used when searching for libraries. </p>
<dl class="section return"><dt>Returns</dt><dd>A list of directories.</dd></dl>
<pre class="fragment">* This is used by the :cpp:func:`qi::path::findLib(const std::string&amp;)`.
*
* .. warning:: You should not assume those directories exist, nor that they are
*    writeable.
* </pre> 
</div>
</div>
<a class="anchor" id="abf76bbd1a7cae43f587b73cc93476ee9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qi::path::listData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>applicationName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pattern</em> = <code>&quot;*&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List data files matching the given pattern in all dataPaths(applicationName) directories. For each match, return the occurence from the first dataPaths prefix. Directories are discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">applicationName</td><td>Name of the application. </td></tr>
    <tr><td class="paramname">pattern</td><td>wilcard pattern of the files to look for. You can specify subdirectories using "/" as directory separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An std::vector of the complete, native paths of the files that matched.</dd></dl>
<pre class="fragment">* Matches are searched in a list of possible directories, provided by the
* :cpp:func:`qi::path::dataPaths(const std::string&amp;)`.
* When several matches collide, the first one is
* returned.
*
* For instance if you have the following files on a unix system
*
*   ~/.local/share/foo/models/nao.xml
*   ~/.local/share/foo/models/romeo_with_laser_head.xml
*   /usr/share/foo/models/nao.xml
*   /usr/share/foo/models/romeo.xml
*
* then listData("foo", "models/*.xml") will return
*
*   ~/.local/share/foo/models/nao.xml
*   ~/.local/share/foo/models/romeo_with_laser_head.xml
*   /usr/share/foo/models/romeo.xml
* </pre> 
</div>
</div>
<a class="anchor" id="a58ef35d77f49e66ea2f6a35bf7503173"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qi::path::sdkPrefix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the default SDK prefix path. </p>
<dl class="section return"><dt>Returns</dt><dd>The SDK prefix path. It's always a complete, native path. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00001.html#a3">qipath_example.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a28fbae233ad984a160a1cbd4bc0f0ffd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qi::path::setWritablePath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the writable files path for users. </p>

</div>
</div>
<a class="anchor" id="a2b005e1a08fe22acb98b0c237c0db803"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qi::path::userWritableConfPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>applicationName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the writable configuration files path for users. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">applicationName</td><td>The name of the application. </td></tr>
    <tr><td class="paramname">filename</td><td>The filename. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The directory or the file.</dd></dl>
<pre class="fragment">* If filename is empty, return the directory
* in which to write. Otherwise the path is constructed like this:
*
* Linux
*    &lt;home&gt;/.config/&lt;applicatioName&gt;/&lt;filename&gt;
*
* Windows
*    %AppData%\&lt;applicatioName&gt;\&lt;filename&gt;
*
* You can specify subdirectories using "/" as directory separator.
* </pre> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00001.html#a6">qipath_example.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a4dbd19303a2be34b9ee8391c336f2a52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qi::path::userWritableDataPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>applicationName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the writable data files path for users. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">applicationName</td><td>The name of the application. </td></tr>
    <tr><td class="paramname">filename</td><td>The filename. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The directory or the file.</dd></dl>
<pre class="fragment">* If filename is empty, return the directory in which to write.
* Otherwise the path is constructed like this:
*
* Linux
*    &lt;home&gt;/.local/share/&lt;applicationName&gt;/&lt;filename&gt;
*
* Windows
*    %AppData%\&lt;applicatioName&gt;\&lt;filename&gt;
*
* You can specify subdirectories using "/" as directory separator.
* </pre> 
</div>
</div>
</div><!-- contents -->

<hr class="footer"/><address class="footer"><small>
Copyright Aldebaran Robotics
<!-- Generated on Tue Oct 6 2015 17:53:47 for libqi-api by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6</small></address> -->
</body>
</html>
